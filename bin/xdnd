#!/bin/bash
# xdnd - xdn daemon shell script
# Script to start xdn node as either Reconfigurator (RC) or Active Replica (AR).

# ensure to throw error for undefined variables.
set -u

# handle perl warning: "perl: warning: Setting locale failed."
LC_CTYPE=en_US.UTF-8
LC_ALL=en_US.UTF-8

# Contains the absolute path of XDN source code (e.g., /users/fadhil/xdn).
# The variable is populated in main() function.
XDN_SRC_PATH="";

function do_system_check() {
  echo "The following systems/dependencies are required to run XDN."
  echo " - Linux 5.15 or newer with x86-64 architecture"
  echo " - libfuse3"
  echo " - Java 21+"
  echo " - Docker 26+, accessible without 'sudo'"
  echo ""
  echo "Checking those requirements are satisfied or not ..."
  echo "Error! unimplemented."
}

# parse_common_dist_args extracts shared distributed args and validates them.
function parse_common_dist_args() {
  local DEFAULT_CONFIG="./conf/gigapaxos.properties"
  local config=$DEFAULT_CONFIG
  local ssh_key=""
  local username=""

  for ARG in "$@"; do
    case $ARG in
    -config=*)
      config="${ARG#*=}"
      ;;
    -ssh-key=*)
      ssh_key="${ARG#*=}"
      ;;
    -username=*)
      username="${ARG#*=}"
      ;;
    esac
  done

  if [ ! -f "$config" ]; then
    echo "Config file '$config' can not be found!" >&2
    return 1
  fi

  if [ -z "$ssh_key" ]; then
    echo "Please specify the ssh key with '-ssh-key=<location>' argument." >&2
    return 1
  fi

  if [ -z "$username" ]; then
    echo "Please specify the username with '-username=<name>' argument." >&2
    return 1
  fi

  printf "%s %s %s\n" "$config" "$ssh_key" "$username"
}

function do_distributed_initialization() {
  echo "Initializing all the machines from the provided config ..."

  local parsed_args
  if ! parsed_args=$(parse_common_dist_args "$@"); then
    exit 1
  fi
  read -r CONFIG SSH_KEY USERNAME <<<"$parsed_args"
  if [[ -z ${CONFIG} || -z ${SSH_KEY} || -z ${USERNAME} ]]; then
    echo "CONFIG, SSH_KEY, and USERNAME must all be provided" >&2
    exit 1
  fi

  # extract unique IPs from the config file
  local unique_ips=()
  while IFS= read -r line; do
    if [[ $line =~ ^(active|reconfigurator)\.[a-zA-Z0-9_]*= ]]; then
      ip=$(echo "$line" | awk -F'[=:]' '{print $2}')
      if [[ ! " ${unique_ips[*]-} " =~ " ${ip} " ]]; then
        unique_ips+=("$ip")
      fi
    fi
  done <"$CONFIG"

  # Print out the unique IPs/Hosts, ssh-key, and username
  echo " - config file       : ${CONFIG}"
  echo " - ssh key           : ${SSH_KEY}"
  echo " - username          : ${USERNAME}"
  echo " - machine IPs/Hosts :"
  for ip in "${unique_ips[@]}"; do
    echo "   - $ip"
  done
  echo ""

  # go over all the machines to install the dependencies
  # and put the xdn source code into the machines.
  for machine in "${unique_ips[@]}"; do
    prepare_ssh_config "$machine" "$CONFIG" "$SSH_KEY" "$USERNAME"
    install_dependencies "$machine" "$SSH_KEY" "$USERNAME"
    upload_binaries "$machine" "$SSH_KEY" "$USERNAME"
  done

  exit 0

  # generate config in all the machines, based on the
  # listed machines in the $MACHINES variable.
  #  for machine in "${MACHINES[@]}"; do
  #    generate_config $machine
  #  done

  # TODO: start the service
}

function do_start_all() {
  echo "Starting all gigapaxos servers defined in the config ..."

  local DEFAULT_CONFIG="./conf/gigapaxos.properties"
  local CONFIG=$DEFAULT_CONFIG
  local SSH_KEY=""
  local USERNAME=""

  for ARG in "$@"; do
    case $ARG in
    -config=*)
      CONFIG="${ARG#*=}"
      ;;
    -ssh-key=*)
      SSH_KEY="${ARG#*=}"
      ;;
    -username=*)
      USERNAME="${ARG#*=}"
      ;;
    esac
  done

  if [ ! -f "$CONFIG" ]; then
    echo "Config file '$CONFIG' can not be found!"
    exit 1
  fi

  if [ -z "$SSH_KEY" ]; then
    echo "Please specify the ssh key with '-ssh-key=<location>' argument."
    exit 1
  fi

  if [ -z "$USERNAME" ]; then
    echo "Please specify the username with '-username=<name>' argument."
    exit 1
  fi

  local CONFIG_DIR
  CONFIG_DIR=$(cd "$(dirname "$CONFIG")" && pwd)
  local CONFIG_ABS="$CONFIG_DIR/$(basename "$CONFIG")"

  local GPSERVER="$XDN_SRC_PATH/bin/gpServer.sh"
  if [ ! -x "$GPSERVER" ]; then
    echo "Unable to find executable gpServer at '$GPSERVER'"
    exit 1
  fi

  echo " - config file : ${CONFIG_ABS}"
  echo " - ssh key     : ${SSH_KEY}"
  echo " - username    : ${USERNAME}"
  echo ""
  echo "Invoking gpServer to start all nodes ..."

  SSH_KEY_PATH="$SSH_KEY" GP_USERNAME="$USERNAME" "$GPSERVER" "-DgigapaxosConfig=$CONFIG_ABS" start all
  exit $?
}

function do_start_ar_instance() {
  echo "unimplemented"
}

function do_start_rc_instance() {
  # get config from parameters, if any.
  local DEFAULT_CONFIG="./conf/gigapaxos.properties"
  local CONFIG=$DEFAULT_CONFIG
  # Parse options using getopts
  for ARG in "$@"; do
    case $ARG in
    -config=*)
      CONFIG="${ARG#*=}"
      ;;
    esac
  done

  # get instance name, the last parameter.
  local INSTANCE_NAME="${@: -1}"

  # get host from the config file.
  local DEFAULT_HOST="0.0.0.0"
  local DEFAULT_PORT="3000"
  local HOST=$DEFAULT_HOST
  local PORT=$DEFAULT_PORT

  echo "..."
  echo " Starting a control plane instance"
  echo "  - config file   : $CONFIG"
  echo "  - instance name : $INSTANCE_NAME"
  echo "  - host address  : $HOST:$PORT"
}

function do_start_dns_ns_instance() {
  # get config from parameters, if any.
  local DEFAULT_CONFIG="./conf/gigapaxos.properties"
  local CONFIG=$DEFAULT_CONFIG

  # Parse options using getopts
  for ARG in "$@"; do
    case $ARG in
    -config=*)
      CONFIG="${ARG#*=}"
      ;;
    esac
  done

  # get instance name, the last parameter.
  local INSTANCE_NAME="${@: -1}"

  # Parse config by the given instance name
  local INSTANCE_HOST_RAW=$(grep "reconfigurator.$INSTANCE_NAME=" "$CONFIG")
  # Split the result using '=' as the separator
  IFS='=' read -r LEFT_PART RIGHT_PART <<< "$INSTANCE_HOST_RAW"
  # Split the result using ':' as the separator
  IFS=':' read -r INSTANCE_HOST_ADDRESS RIGHT_PART <<< "$RIGHT_PART"

  echo "Target machine for dns installation: $INSTANCE_HOST_ADDRESS"


  # TODO: get instance information from config file
  # TODO: copy the dns source code
  # TODO: copy the geolocation database to /tmp/geo/geolocation_city_data.mmdb
  # TODO: compile the source code
  # TODO: update the Corefile
  # TODO: possibly edit the resolved configuration

  echo "unimplemented :("
}

function do_start_instance() {
  local STARTED_INSTANCE_TYPE=$2
  case "$STARTED_INSTANCE_TYPE" in
  "control-plane")
    echo "starting a control plane instance ..."
    do_start_rc_instance "$@"
    ;;
  "dns")
    echo "starting a dns nameserver instance ..."
    do_start_dns_ns_instance "$@"
    ;;
  "machine")
    echo "starting an active instance ..."
    do_start_rc_instance "$@"
    ;;
  *)
    echo "starting an active instance ..."
    do_start_rc_instance "$@"
    ;;
  esac
}

# prepare_ssh_config prepares the ssh config file to avoid host key checking prompts,
# assuming all machines share the same ssh key and cloudlab machines with 10.10.x.x ips.
# arg-1: machine ip address
# arg-2: config file
# arg-3: ssh-key location
# arg-4: username for ssh
function prepare_ssh_config() {
  if [ "$#" -lt 4 ]; then
    echo "prepare_ssh_config expects 4 args (node, config, ssh_key, username)" >&2
    return 1
  fi

  local node=$1;
  local config_file=$2;
  local ssh_key=$3;
  local username=$4;

  echo "Preparing ssh config for machine $node ..."

  local tmp_config
  tmp_config=$(mktemp)

  # extract unique IPs from the config file
  local unique_ips=()
  while IFS= read -r line; do
    if [[ $line =~ ^(active|reconfigurator)\.[a-zA-Z0-9_]*= ]]; then
      ip=$(echo "$line" | awk -F'[=:]' '{print $2}')
      if [[ ! " ${unique_ips[*]-} " =~ " ${ip} " ]]; then
        unique_ips+=("$ip")
      fi
    fi
  done <"$config_file"

  # prepare ssh config file
  for host in "${unique_ips[@]}"; do
    cat >>"$tmp_config" <<EOF
Host $host
  User $username
  IdentityFile /users/$username/.ssh/xdn_ssh_key
  StrictHostKeyChecking no

EOF
  done

  # distribute the ssh config and key to the target machine
  ssh_key="${ssh_key/#\~/$HOME}"
  ssh -i "$ssh_key" -o StrictHostKeyChecking=no "$username@$node" "mkdir -p ~/.ssh && chmod 700 ~/.ssh"
  scp -i "$ssh_key" -o StrictHostKeyChecking=no $ssh_key "$username@$node:~/.ssh/xdn_ssh_key"
  scp -i "$ssh_key" -o StrictHostKeyChecking=no "$tmp_config" "$username@$node:~/.ssh/config"
  ssh -i "$ssh_key" -o StrictHostKeyChecking=no "$username@$node" "chmod 600 ~/.ssh/config"
  rm -f "$tmp_config"

  # also prepare local ssh config for this machine,
  # ideally this should be done only once outside the this prepare_ssh_config function
  # that is called multiple times for each remote machine.
  local local_ssh_dir="$HOME/.ssh"
  local local_ssh_key="$local_ssh_dir/xdn_ssh_key"
  local local_config_file="$local_ssh_dir/config"
  mkdir -p "$local_ssh_dir"
  chmod 700 "$local_ssh_dir"
  cp $ssh_key "$local_ssh_key"
  chmod 600 "$local_ssh_key"
  local local_tmp_config
  local_tmp_config=$(mktemp)
  for host in "${unique_ips[@]}"; do
    cat >>"$local_tmp_config" <<EOF
Host $host
  User $username
  IdentityFile $local_ssh_key
  StrictHostKeyChecking no

EOF
  done
  mv "$local_tmp_config" "$local_config_file"
  chmod 600 "$local_config_file"
}

# install_dependencies installs all the required dependencies for xdn (e.g., docker)
# arg-1: machine ip address
# arg-2: ssh-key location
# arg-3: username for ssh
function install_dependencies() {
  local node=$1;
  local ssh_key=$2;
  local username=$3;
  local golang_tar_name="go1.22.4.linux-amd64.tar.gz";
  local golang_download_url="https://go.dev/dl/go1.22.4.linux-amd64.tar.gz";

  echo "Installing dependencies on machine $node with user '$username' ..."

  CMD=()
  CMD_DESC=()

  CMD_DESC+=("update apt packages")
  CMD+=("sudo apt-get update")
  CMD_DESC+=("install dialog frontend")
  CMD+=("sudo DEBIAN_FRONTEND=noninteractive apt-get install dialog apt-utils -y")

  # libfuse3
  CMD_DESC+=("install libfuse3 for Fuselog")
  CMD+=("sudo DEBIAN_FRONTEND=noninteractive apt-get install -y pkg-config libfuse3-dev")

  # install golang
  CMD_DESC+=("download golang")
  CMD+=("wget --quiet --no-clobber $golang_download_url && sudo rm -rf /usr/local/go")
  CMD_DESC+=("extract golang")
  CMD+=("sudo tar -C /usr/local -xzf $golang_tar_name")
  CMD_DESC+=("add golang to PATH var")
  CMD+=('echo "export PATH=$PATH:/usr/local/go/bin" | sudo tee -a /etc/environment')

  # install docker
  CMD_DESC+=("install docker - (0) preparation")
  CMD+=("echo 'debconf debconf/frontend select Noninteractive' | sudo debconf-set-selections")
  CMD_DESC+=("install docker - (1) install certificate and curl")
  CMD+=("sudo apt-get install -y -q ca-certificates curl")
  CMD_DESC+=("install docker - (2) install keyrings")
  CMD+=("sudo install -m 0755 -d /etc/apt/keyrings")
  CMD_DESC+=("install docker - (3) get gpg keys")
  CMD+=("sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc")
  CMD_DESC+=("install docker - (4) change permission for key")
  CMD+=("sudo chmod a+r /etc/apt/keyrings/docker.asc")
  CMD_DESC+=("install docker - (5) update apt sources")
  CMD+=('echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null')
  CMD_DESC+=("install docker - (6) get docker from the newly registered repo")
  CMD+=("sudo apt-get update -y -q && sudo apt-get install -y -q docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin")

  # make docker accessible without sudo by the used user
  CMD_DESC+=("install docker - (7) create docker group")
  CMD+=("sudo groupadd -f docker")
  CMD_DESC+=("install docker - (8) add user to docker group")
  CMD+=('sudo usermod -aG docker $USER')

  # install java21
  CMD_DESC+=("install java21")
  CMD+=("sudo DEBIAN_FRONTEND=noninteractive apt-get install -y openjdk-21-jdk ant")

  # install python3-pip and tcconfig for WAN latency emulation
  CMD_DESC+=("install pip")
  CMD+=("sudo DEBIAN_FRONTEND=noninteractive apt-get install -y python3-pip")
  CMD_DESC+=("install tcconfig for WAN latency emulation")
  CMD+=("sudo pip install -q tcconfig")

  # install rqlite for the geodistributed baseline
  local rqlite_folder_name="rqlite-v8.36.12-linux-amd64"
  local rqlite_tar_name="rqlite-v8.36.12-linux-amd64.tar.gz"
  local rqlite_download_url="https://github.com/rqlite/rqlite/releases/download/v8.36.12/rqlite-v8.36.12-linux-amd64.tar.gz"
  CMD_DESC+=("download rqlite")
  CMD+=("wget --quiet --no-clobber $rqlite_download_url && rm -rf $rqlite_folder_name")
  CMD_DESC+=("extract rqlite")
  CMD+=("tar xvfz $rqlite_tar_name && rm -rf rqlite && mv $rqlite_folder_name rqlite")
  CMD_DESC+=("add rqlite to PATH var")
  CMD+=('echo "export PATH=$PATH:$PWD/rqlite" | sudo tee -a /etc/environment')

  # install node for the durable object baseline
  CMD_DESC+=("install npm")
  CMD+=("sudo apt-get install -y npm")
  CMD_DESC+=("update node version to latest stable")
  CMD+=("sudo npm install -g n && sudo n stable && hash -r && sudo npm install --save-dev wrangler@4")

  for i in "${!CMD_DESC[@]}"; do
    desc=${CMD_DESC[$i]}
    cmd=${CMD[$i]}
    echo "     $desc ..."
    ssh -o StrictHostKeyChecking=no -i $ssh_key $username@$node "nohup $cmd" 2>&1 >/dev/null
    return_code=$?
    ret=$?
    if [ $return_code -ne 0 ]; then
      echo " [ERROR] failed to run command '$cmd'."
    fi
  done
  echo ""
}

# copy_binaries transfer all the required binaries to the remote machines
# specified in the config file (i.e., gigapaxos.properties)
# arg-1: machine ip address
# arg-2: ssh-key location
# arg-3: username for ssh
function upload_binaries() {
  local node=$1
  local ssh_key=$2;
  local username=$3;
  local xdn_src_dir=$XDN_SRC_PATH;

  # copy from current source into the target machine
  echo "Uploading XDN binaries from $xdn_src_dir/ ..."
  ssh -o StrictHostKeyChecking=no -i $ssh_key $username@$node "rm -rf xdn"
  rsync -Pav -e "ssh -i $ssh_key -q" --exclude=".*/" -q -a $xdn_src_dir/ $username@$node:~/xdn

  # TODO: check that fuselog and fuselog-apply are working

  CMD=()
  CMD+=('/$HOME/xdn/bin/build_xdn_cli.sh')
  CMD+=("sudo rm -rf /usr/local/bin/xdn")
  CMD+=("sudo rm -rf /usr/local/bin/fuselog")
  CMD+=("sudo rm -rf /usr/local/bin/fuselog-apply")
  CMD+=("sudo rm -rf /usr/local/bin/fuserust")
  CMD+=("sudo rm -rf /usr/local/bin/fuserust-apply")
  CMD+=('sudo ln -s $HOME/xdn/bin/xdn /usr/local/bin/xdn')
  CMD+=('sudo ln -s $HOME/xdn/bin/fuselog /usr/local/bin/fuselog')
  CMD+=('sudo ln -s $HOME/xdn/bin/fuselog-apply /usr/local/bin/fuselog-apply')
  CMD+=('sudo ln -s $HOME/xdn/bin/fuselog /usr/local/bin/fuserust')
  CMD+=('sudo ln -s $HOME/xdn/bin/fuselog-apply /usr/local/bin/fuserust-apply')
  CMD+=("sudo sed -i 's/#user_allow_other/user_allow_other/g' /etc/fuse.conf")
  for i in "${!CMD[@]}"; do
    cmd=${CMD[$i]}
    ssh -o StrictHostKeyChecking=no -i $ssh_key $username@$node "$cmd" 2>&1 > /dev/null
    return_code=$?
    ret=$?
    if [ $return_code -ne 0 ]; then
      echo " [ERROR] failed to run command '$cmd'."
    fi
  done
  echo ""
}

# arg-1: machine ip address
function generate_config() {
  node=$1

  echo "generating config for machine $node"
  echo "unimplemented :("
}

function print_usage() {
  echo "Usage: xdnd [actions]"
  echo ""
  echo " Available commands are listed below."
  echo " To initialize all the machines, installing required dependencies:"
  echo "   xdnd dist-init -config=gigapaxos.properties -ssh-key=/ssh/key -username=user"
  echo ""
  echo " To start all gigapaxos servers using gpServer:"
  echo "   xdnd start-all -config=gigapaxos.properties -ssh-key=/ssh/key -username=user"
  echo ""
  echo " To initialize distributed observability:"
  echo "   xdnd dist-init-observability -config=gigapaxos.properties -ssh-key=/ssh/key -username=user"
  echo ""
  echo " To initialize the driver machine:"
  echo "   xdnd init-driver"
  echo ""
  echo " To start a reconfigurator instance:"
  echo "   xdnd start control-plane -config=gigapaxos.properties RC0"
  echo ""
  echo " To start an active replica instance from the initialized machine:"
  echo "   xdnd start machine -config=gigapaxos.properties AR0"
  echo "   xdnd start -config=gigapaxos.properties AR0"
  echo ""
  echo " To start an active replica and make it join existing xdn deployment:"
  echo "   xdnd start -join=10.10.10.10 -host=11.11.11.11 AR10"
}

# checks if a string is in the list
function is_in_list() {
  local item="$1"
  shift
  local list=("$@")

  for element in "${list[@]}"; do
    if [[ "$element" == "$item" ]]; then
      return 0
    fi
  done
  return 1
}

# install_node_exporter_on_remote ensures each remote node has node-exporter managed via systemd
function install_node_exporter_on_remote() {
  local node=$1
  local ssh_key=$2
  local username=$3

  echo "[REMOTE] Installing node-exporter on $node ..."
  ssh -o StrictHostKeyChecking=no -i "$ssh_key" "$username@$node" 'bash -s' <<'ENDSSH'
    set -e
    if ! command -v wget >/dev/null 2>&1; then
      sudo apt-get update && sudo apt-get install -y wget
    fi
    NODE_EXPORTER_VERSION="1.8.2"
    NODE_EXPORTER_DIR="node_exporter-${NODE_EXPORTER_VERSION}.linux-amd64"
    NODE_EXPORTER_TAR="${NODE_EXPORTER_DIR}.tar.gz"
    if ! command -v node_exporter >/dev/null 2>&1; then
      wget -q https://github.com/prometheus/node_exporter/releases/download/v${NODE_EXPORTER_VERSION}/${NODE_EXPORTER_TAR}
      tar xzf ${NODE_EXPORTER_TAR}
      sudo mv ${NODE_EXPORTER_DIR}/node_exporter /usr/local/bin/
      sudo chmod 755 /usr/local/bin/node_exporter
      rm -rf ${NODE_EXPORTER_DIR} ${NODE_EXPORTER_TAR}
    fi
    if ! getent group node_exporter >/dev/null 2>&1; then
      sudo groupadd --system node_exporter
    fi
    if ! id -u node_exporter >/dev/null 2>&1; then
      sudo useradd --system --no-create-home --shell /usr/sbin/nologin -g node_exporter node_exporter
    fi
    if [ ! -f /etc/systemd/system/node_exporter.service ]; then
      sudo tee /etc/systemd/system/node_exporter.service >/dev/null <<'SERVICE'
[Unit]
Description=Prometheus Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=node_exporter
Group=node_exporter
Type=simple
ExecStart=/usr/local/bin/node_exporter

[Install]
WantedBy=multi-user.target
SERVICE
      sudo systemctl daemon-reload
      sudo systemctl enable --now node_exporter
    else
      sudo systemctl daemon-reload
      sudo systemctl restart node_exporter
    fi
    echo "node-exporter installed."
ENDSSH
}

# update_prometheus_scrape_config ensures local Prometheus scrapes all node exporters
function update_prometheus_scrape_config() {
  local nodes=("$@")
  local prom_tmp

  echo "[LOCAL] Updating Prometheus configuration with node-exporter targets ..."
  prom_tmp=$(mktemp)
  cat >"$prom_tmp" <<'PROMHDR'
global:
  scrape_interval: 15s
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
  - job_name: 'node_exporter'
    static_configs:
      - targets:
PROMHDR
  for ip in "${nodes[@]}"; do
    echo "        - '${ip}:9100'" >>"$prom_tmp"
  done
  echo "        - 'localhost:9100'" >>"$prom_tmp"
  sudo mv "$prom_tmp" /etc/prometheus/prometheus.yml
  sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml
  sudo chmod 644 /etc/prometheus/prometheus.yml
  sudo systemctl restart prometheus
}

# provision_node_exporter_dashboard configures Grafana to use Prometheus and import the Node Exporter dashboard
function provision_node_exporter_dashboard() {
  echo "[LOCAL] Provisioning Grafana data source and Node Exporter Full dashboard ..."
  if ! command -v curl >/dev/null 2>&1; then
    sudo apt-get install -y curl
  fi
  sudo mkdir -p /etc/grafana/provisioning/datasources
  sudo mkdir -p /etc/grafana/provisioning/dashboards
  sudo mkdir -p /var/lib/grafana/dashboards/node_exporter
  sudo tee /etc/grafana/provisioning/datasources/prometheus.yaml >/dev/null <<'DATASOURCE'
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://localhost:9090
    isDefault: true
    editable: false
DATASOURCE
  sudo tee /etc/grafana/provisioning/dashboards/node_exporter.yaml >/dev/null <<'DASHCFG'
apiVersion: 1
providers:
  - name: Node Exporter Full
    folder: Node Exporter
    type: file
    disableDeletion: false
    updateIntervalSeconds: 60
    allowUiUpdates: true
    options:
      path: /var/lib/grafana/dashboards/node_exporter
    inputs:
      - name: DS_PROMETHEUS
        type: datasource
        pluginId: prometheus
        value: Prometheus
DASHCFG
  local dash_tmp
  dash_tmp=$(mktemp)
  if ! curl -fsSL https://grafana.com/api/dashboards/1860/revisions/latest/download -o "$dash_tmp"; then
    echo "[ERROR] Failed to download Node Exporter Full dashboard JSON." >&2
    exit 1
  fi
  sudo mv "$dash_tmp" /var/lib/grafana/dashboards/node_exporter/node_exporter_full.json
  sudo chown -R grafana:grafana /etc/grafana/provisioning /var/lib/grafana/dashboards
  sudo chmod -R a+rX /etc/grafana/provisioning /var/lib/grafana/dashboards
  sudo systemctl restart grafana-server
}

# provision_k6_prometheus_dashboard imports the official k6 Prometheus dashboard into Grafana
function provision_k6_prometheus_dashboard() {
  echo "[LOCAL] Provisioning k6 Prometheus dashboard ..."
  if ! command -v curl >/dev/null 2>&1; then
    sudo apt-get install -y curl
  fi
  sudo mkdir -p /etc/grafana/provisioning/dashboards
  sudo mkdir -p /var/lib/grafana/dashboards/k6
  sudo tee /etc/grafana/provisioning/dashboards/k6_prometheus.yaml >/dev/null <<'DASHCFG'
apiVersion: 1
providers:
  - name: k6 Prometheus
    folder: k6
    type: file
    disableDeletion: false
    updateIntervalSeconds: 60
    allowUiUpdates: true
    options:
      path: /var/lib/grafana/dashboards/k6
    inputs:
      - name: DS_PROMETHEUS
        type: datasource
        pluginId: prometheus
        value: Prometheus
DASHCFG
  local dash_tmp
  dash_tmp=$(mktemp)
  if ! curl -fsSL https://grafana.com/api/dashboards/19665/revisions/latest/download -o "$dash_tmp"; then
    echo "[ERROR] Failed to download k6 Prometheus dashboard JSON." >&2
    exit 1
  fi
  sudo mv "$dash_tmp" /var/lib/grafana/dashboards/k6/k6_prometheus.json
  sudo chown -R grafana:grafana /etc/grafana/provisioning /var/lib/grafana/dashboards
  sudo chmod -R a+rX /etc/grafana/provisioning /var/lib/grafana/dashboards
  sudo systemctl restart grafana-server
}

# install_prometheus installs Prometheus and enables remote write receiver
function install_prometheus() {
  echo "[LOCAL] Installing Prometheus with remote-write receiver ..."
  sudo apt-get install -y prometheus
  sudo mkdir -p /etc/systemd/system/prometheus.service.d
  sudo tee /etc/systemd/system/prometheus.service.d/remote-write.conf >/dev/null <<'PROMDROP'
[Service]
ExecStart=
ExecStart=/usr/bin/prometheus \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/var/lib/prometheus \
  --web.console.templates=/etc/prometheus/consoles \
  --web.console.libraries=/etc/prometheus/console_libraries \
  --enable-feature=remote-write-receiver
PROMDROP
  sudo systemctl daemon-reload
  sudo systemctl enable prometheus
  sudo systemctl restart prometheus
}

# do_distributed_init_observability sets up observability tools locally and remotely
# Installs grafana, k6, and prometheus locally, and node-exporter on all remote nodes
function do_distributed_init_observability() {
  echo "Initializing distributed observability setup ..."

  local parsed_args
  if ! parsed_args=$(parse_common_dist_args "$@"); then
    exit 1
  fi
  read -r CONFIG SSH_KEY USERNAME <<<"$parsed_args"

  if [[ -z ${CONFIG} || -z ${SSH_KEY} || -z ${USERNAME} ]]; then
    echo "CONFIG, SSH_KEY, and USERNAME must all be provided" >&2
    exit 1
  fi

  # extract unique IPs from the config file
  local unique_ips=()
  while IFS= read -r line; do
    if [[ $line =~ ^(active|reconfigurator)\.[a-zA-Z0-9_]*= ]]; then
      ip=$(echo "$line" | awk -F'[=:]' '{print $2}')
      if [[ ! " ${unique_ips[*]-} " =~ " ${ip} " ]]; then
        unique_ips+=("$ip")
      fi
    fi
  done <"$CONFIG"

  echo " - config file       : ${CONFIG}"
  echo " - ssh key           : ${SSH_KEY}"
  echo " - username          : ${USERNAME}"
  echo " - machine IPs/Hosts :"
  for ip in "${unique_ips[@]}"; do
    echo "   - $ip"
  done
  echo ""

  # Install Grafana, k6, and Prometheus locally
  echo "[LOCAL] Installing Grafana, k6, and Prometheus ..."
  if command -v apt-get >/dev/null 2>&1; then
    # Installing and enabling Grafana
    sudo apt-get update
    sudo apt-get install -y software-properties-common
    sudo add-apt-repository -y "deb https://packages.grafana.com/oss/deb stable main"
    wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -
    sudo apt-get update
    sudo apt-get install -y grafana
    sudo systemctl start grafana-server
    sudo systemctl enable grafana-server

    # Installing k6
    sudo gpg -k
    sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
    echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
    sudo apt-get update
    sudo apt-get install -y k6

    # Installing Prometheus with remote-write receiver
    install_prometheus
  else
    echo "[WARN] apt-get not found. Please install Grafana, k6, and Prometheus manually."
  fi

  # Install node-exporter on all remote nodes
  for machine in "${unique_ips[@]}"; do
    install_node_exporter_on_remote "$machine" "$SSH_KEY" "$USERNAME"
  done

  if command -v apt-get >/dev/null 2>&1; then
    # Update Prometheus config with all node-exporter targets
    update_prometheus_scrape_config "${unique_ips[@]}"

    # Provision Grafana data source and Node Exporter Full dashboard
    provision_node_exporter_dashboard

    # Provision Grafana dashboard for k6 Prometheus metrics
    provision_k6_prometheus_dashboard
  fi

  echo "Distributed observability setup complete."
  echo "Access Grafana at http://localhost:3000"
  exit 0
}

# Initializes the driver machine with all required dependencies and setup
function do_init_driver() {
  echo "Initializing driver machine ..."

  sudo apt update
  sudo apt install -y golang-go openjdk-21-jdk apache2-utils python3-pip ant screen
  curl https://sh.rustup.rs -sSf | sh -s -- -y
  source $HOME/.cargo/env
  python -m pip install -U pip
  python -m pip install -U matplotlib
  python -m pip install -U scikit-learn
  python -m pip install -U requests
  python -m pip install -U pandas
  python -m pip install -U basemap

  ant jar
  ./bin/build_xdn_cli.sh
  sudo rm -rf /usr/local/bin/xdn && sudo ln -s "$PWD/bin/xdn" "/usr/local/bin/xdn"
  mkdir -p eval/screen_logs
  sudo mkdir -p /mydata/latency-results && sudo chmod 777 /mydata/latency-results
  cd eval/xdn_latency_proxy_go && go build .
  cd -

  echo "Dont forget to initialize machines for xdn cluster using 'xdnd dist-init'"
  exit 0
}

# main() is the main entrypoint of this shell script that validates the actions
# (i.e., start, check, dist-launch, help), then handle the action accordingly.
function main() {

  # validate the program name, which must be 'xdnd'.
  local PROGRAM_NAME=$(basename "$0")
  if [[ "$PROGRAM_NAME" != "xdnd" ]]; then
    echo "Invalid program name. Must be 'xdnd'."
    exit 1
  fi

  # Find out the absolute path of XDN source code, assuming
  # this bash program is ./bin/xdnd inside the XDN source code.
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  XDN_SRC_PATH="$(cd $SCRIPT_DIR && cd ../ && pwd)"

  # check the number of parameter.
  if [ "$#" -eq 0 ]; then
    echo "No action is provided."
    echo "Valid actions are: start, check, dist-init, help."
    echo ""
    print_usage
    exit 1
  fi

  # parse the second param, i.e., the action.
  local SECOND_PARAM=$1
  local VALID_ACTIONS=("dist-init" "dist-init-observability" "start-all" "init-driver" "start" "help" "check")
  if ! is_in_list "$SECOND_PARAM" "${VALID_ACTIONS[@]}"; then
    echo "Action '$SECOND_PARAM' is not a valid actions."
    echo "Valid actions are: start, check, dist-init, help."
    echo ""
    print_usage
    exit 1
  fi
  local ACTION=$SECOND_PARAM

  case "$ACTION" in
  "dist-init")
    do_distributed_initialization "$@"
    ;;
  "dist-init-observability")
    do_distributed_init_observability "$@"
    ;;
  "start-all")
    do_start_all "$@"
    ;;
  "init-driver")
    do_init_driver "$@"
    ;;
  "start")
    echo "starting an instance ..."
    do_start_instance "$@"
    ;;
  "check")
    do_system_check
    ;;
  "help")
    print_usage
    ;;
  *)
    echo "Invalid action. Valid actions are: start, check, dist-init, help."
    exit 1
    ;;
  esac
  exit 0
}

# the starting point of this shell script
main "$@"
